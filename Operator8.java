package oop20230710;

public class Operator8 {

	public static void main(String[] args) {
		// 교재:83p
		//비트(Bitwise) 논리 연산자: 0,1
		//NOT(논리부정): ~
		//AND(논리곱):&
		//XOR(배타적논리합):^
		//OR(논리합):|
		
		
		//AND: &, 두 비트가 1이면 -> 결과 1
		int a = 5;     //0 0000000 00000000 00000000 00000101
		int b = 2;     //0 0000000 00000000 00000000 00000010
		int c = a & b; //0 0000000 00000000 00000000 00000000
		System.out.println(c);
		System.out.println();
		//OR: |,두 비트중 하나만 1이면 -> 결과 1
		a = 5;     //0 0000000 00000000 00000000 00000101
		b = 2;     //0 0000000 00000000 00000000 00000010
		c = a | b; //0 0000000 00000000 00000000 00000111
		System.out.println(c);
		System.out.println();
		//XOR: ^, 배타적 논리합, 두 비트가 서로 다르면 -> 결과 1
		a = 5;     //0 0000000 00000000 00000000 00000101
		b = 2;     //0 0000000 00000000 00000000 00000010
		c = a ^ b; //0 0000000 00000000 00000000 00000111
		System.out.println(c);
		System.out.println();
		//NOT논리 부정 연산: !x
		System.out.println(!true);
		System.out.println(!false);
		System.out.println();
		//NOT비트 논리 부정 연산자: ~x, (결과)0이면 1로 1이면 0으로 
		int x = 2;
		int y = ~x;//~부호를 하면 모든 비트가 반대로바뀜
		System.out.println(y);//(결과) -3
		//x(2)  : 0 0000000 00000000 00000000 00000010
		//~x(~2): 1 1111111 11111111 11111111 11111101
		//y [부호와 2의보수]:1 1111111 11111111 11111111 11111101
		//y [부호와 1의보수]:1 1111111 11111111 11111111 11111100
		//y [부호와 절대치] :1 0000000 00000000 00000000 00000011
		//y [출력, 10진수]:-3
		
		
		
		
		
		
		
		
		
		
	}//main()end

}//class()end
